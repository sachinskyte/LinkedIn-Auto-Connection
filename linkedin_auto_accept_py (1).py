# -*- coding: utf-8 -*-
"""linkedin_auto_accept.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19ZeOdAtX_dOJ3AXxbZ64NXwYnw1JpDbk
"""

!pip install selenium
!pip install webdriver_manager
!apt-get update
!apt install chromium-chromedriver

!wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
!dpkg -i google-chrome-stable_current_amd64.deb
!apt-get -f install -y

!google-chrome --version

!pip install webdriver-manager # Install webdriver-manager

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
import time
import logging
import pickle
import getpass

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def wait_and_find_element(driver, by, value, timeout=10):
    """Helper function to wait for and find an element"""
    try:
        element = WebDriverWait(driver, timeout).until(
            EC.presence_of_element_located((by, value))
        )
        return element
    except TimeoutException:
        logging.error(f"Timeout waiting for element: {value}")
        return None

def login_linkedin():
    """Handle LinkedIn login with OTP verification"""
    # Get credentials at runtime
    print("\n=== LinkedIn Login ===")
    username = input("Enter your LinkedIn email: ")
    password = getpass.getpass("Enter your LinkedIn password: ")

    # Configure Chrome options
    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument('--headless')
    chrome_options.add_argument('--no-sandbox')
    chrome_options.add_argument('--disable-dev-shm-usage')
    chrome_options.add_argument('--disable-gpu')

    try:
        # Initialize the Chrome driver
        driver = webdriver.Chrome(options=chrome_options)
        logging.info("Chrome WebDriver initialized successfully")

        # Navigate to LinkedIn login page
        driver.get('https://www.linkedin.com/login')
        logging.info("Navigating to LinkedIn login page")

        # Enter username
        username_field = wait_and_find_element(driver, By.ID, 'username')
        if username_field:
            username_field.send_keys(username)
            logging.info("Username entered")
        else:
            raise Exception("Could not find username field")

        # Enter password
        password_field = wait_and_find_element(driver, By.ID, 'password')
        if password_field:
            password_field.send_keys(password)
            logging.info("Password entered")
        else:
            raise Exception("Could not find password field")

        # Click Login
        submit_button = wait_and_find_element(driver, By.XPATH, '//button[@type="submit"]')
        if submit_button:
            submit_button.click()
            logging.info("Login button clicked")
        else:
            raise Exception("Could not find submit button")

        # Wait for OTP input
        logging.info("Waiting for OTP input...")
        print("\nCheck your email for the verification code.")
        otp = input("Enter the OTP received: ")

        # Find and enter OTP
        otp_field = wait_and_find_element(driver, By.ID, 'input__email_verification_pin')
        if otp_field:
            otp_field.send_keys(otp)
            logging.info("OTP entered")

            # Submit OTP
            verify_button = wait_and_find_element(driver, By.ID, 'email-pin-submit-button')
            if verify_button:
                verify_button.click()
                logging.info("OTP submitted")
            else:
                raise Exception("Could not find OTP submit button")
        else:
            raise Exception("Could not find OTP input field")

        # Wait for login to complete
        time.sleep(5)

        # Save cookies after successful login
        cookies = driver.get_cookies()
        with open('linkedin_cookies.pkl', 'wb') as file:
            pickle.dump(cookies, file)
        logging.info("Cookies saved successfully")

        return True

    except Exception as e:
        logging.error(f"An error occurred during login: {str(e)}")
        return False

    finally:
        try:
            driver.quit()
            logging.info("Browser closed successfully")
        except Exception as e:
            logging.error(f"Error closing browser: {str(e)}")

if __name__ == "__main__":
    login_linkedin()

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, ElementClickInterceptedException
import time
import logging
import pickle

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def wait_and_find_element(driver, by, value, timeout=10):
    """Helper function to wait for and find an element"""
    try:
        element = WebDriverWait(driver, timeout).until(
            EC.presence_of_element_located((by, value))
        )
        return element
    except TimeoutException:
        logging.error(f"Timeout waiting for element: {value}")
        return None

def accept_connections():
    """Handle accepting connection requests"""
    # Configure Chrome options specifically for Colab
    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument('--headless')
    chrome_options.add_argument('--no-sandbox')
    chrome_options.add_argument('--disable-dev-shm-usage')
    chrome_options.add_argument('--disable-gpu')
    chrome_options.add_argument('--window-size=1920,1080')

    try:
        driver = webdriver.Chrome(options=chrome_options)
        logging.info("Chrome WebDriver initialized successfully")

        # Load cookies from file
        try:
            driver.get('https://www.linkedin.com')
            with open('linkedin_cookies.pkl', 'rb') as file:
                cookies = pickle.load(file)
                for cookie in cookies:
                    driver.add_cookie(cookie)
            logging.info("Cookies loaded successfully")
        except Exception as e:
            logging.error(f"Error loading cookies: {str(e)}")
            return

        # Navigate to Connection Requests Page
        driver.get('https://www.linkedin.com/mynetwork/invitation-manager/')
        logging.info("Navigating to invitation manager")
        time.sleep(5)

        connections_accepted = 0
        max_scrolls = 5
        scroll_count = 0

        while scroll_count < max_scrolls:
            connections_in_current_scroll = 0

            # Check for accept buttons
            accept_buttons = driver.find_elements(By.CSS_SELECTOR, "button[aria-label*='Accept']")
            if not accept_buttons:
                accept_buttons = driver.find_elements(By.XPATH, "//button[contains(@class, 'artdeco-button--secondary')]")
            if not accept_buttons:
                accept_buttons = driver.find_elements(By.XPATH, "//button[contains(., 'Accept')]")

            if not accept_buttons:
                print("No connection requests found!")
                break

            # Process accept buttons
            for button in accept_buttons:
                try:
                    # Check if button still exists and is visible
                    if not button.is_displayed():
                        continue

                    # Scroll button into view
                    driver.execute_script("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", button)
                    time.sleep(1)

                    # Verify button is still clickable before clicking
                    try:
                        WebDriverWait(driver, 3).until(
                            EC.element_to_be_clickable((By.ID, button.get_attribute("id")))
                        )
                    except:
                        continue

                    # Try to click and verify the button was actually clicked
                    initial_button_count = len(driver.find_elements(By.CSS_SELECTOR, "button[aria-label*='Accept']"))
                    driver.execute_script("arguments[0].click();", button)
                    time.sleep(1)

                    # Verify button count has decreased (meaning connection was accepted)
                    new_button_count = len(driver.find_elements(By.CSS_SELECTOR, "button[aria-label*='Accept']"))
                    if new_button_count < initial_button_count:
                        connections_accepted += 1
                        connections_in_current_scroll += 1
                        print(f"Successfully accepted connection {connections_accepted}")

                    time.sleep(2)
                except Exception as e:
                    print(f"Failed to process button: {str(e)}")
                    continue

            if connections_in_current_scroll == 0:
                print("No new connections were accepted in this scroll.")
                break

            # Scroll to load more
            driver.execute_script("window.scrollTo(0, document.documentElement.scrollHeight);")
            time.sleep(3)
            scroll_count += 1

        print(f"Script completed. Total connections actually accepted: {connections_accepted}")
        if connections_accepted == 0:
            print("No connections were successfully accepted. All caught up!")

    finally:
        driver.quit()
        print("Browser closed successfully")

if __name__ == "__main__":
    accept_connections()